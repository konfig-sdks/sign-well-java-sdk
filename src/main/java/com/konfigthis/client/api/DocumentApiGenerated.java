/*
 * Resources and endpoints
 * When I started SignWell in 2019, I saw there was a need for an alternative to the hard-to-use and expensive e-signature software already out there. Documents can be complicated enough, but getting a document signed shouldn't be complicated too.  At SignWell, we pride ourselves not only on the ease and affordability of our e-signature process but also on our personalized and industry-leading customer support — whether it's for individual use or larger team accounts, SignWell is here to help you feel comfortable and confident getting your documents signed.  The SignWell mission? Simplify how documents get signed for millions of people and businesses. We're excited to help you continue to move toward the future of paperless document signing.  Ruben Gamez Founder, SignWell
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AdditionalFilesMapInner;
import com.konfigthis.client.model.AttachmentRequestsMapInner;
import com.konfigthis.client.model.CopiedContactsMapInner;
import com.konfigthis.client.model.DocumentCreateFromTemplateResponse;
import com.konfigthis.client.model.DocumentCreateNewDocumentResponse;
import com.konfigthis.client.model.DocumentFromTemplateRequest;
import com.konfigthis.client.model.DocumentGetDocumentDataResponse;
import com.konfigthis.client.model.DocumentRecipientsMapInner;
import com.konfigthis.client.model.DocumentRequest;
import com.konfigthis.client.model.DocumentSendReminderResponse;
import com.konfigthis.client.model.DocumentUpdateAndSendResponse;
import com.konfigthis.client.model.FilesMapInner;
import com.konfigthis.client.model.RemindRecipientsMapInner;
import com.konfigthis.client.model.SendReminderRequest;
import com.konfigthis.client.model.TemplateFieldsMapInner;
import com.konfigthis.client.model.TemplateRecipientsMapInner;
import java.util.UUID;
import com.konfigthis.client.model.UpdateDocumentAndSendRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class DocumentApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DocumentApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public DocumentApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        if (apiClient.getApiKey() == null) {
            throw new IllegalArgumentException("\"X-Api-Key\" is required but no API key was provided. Please set \"X-Api-Key\" with ApiClient#setApiKey(String).");
        }
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createFromTemplateCall(DocumentFromTemplateRequest documentFromTemplateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = documentFromTemplateRequest;

        // create path and map variables
        String localVarPath = "/api/v1/document_templates/documents";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createFromTemplateValidateBeforeCall(DocumentFromTemplateRequest documentFromTemplateRequest, final ApiCallback _callback) throws ApiException {
        return createFromTemplateCall(documentFromTemplateRequest, _callback);

    }


    private ApiResponse<DocumentCreateFromTemplateResponse> createFromTemplateWithHttpInfo(DocumentFromTemplateRequest documentFromTemplateRequest) throws ApiException {
        okhttp3.Call localVarCall = createFromTemplateValidateBeforeCall(documentFromTemplateRequest, null);
        Type localVarReturnType = new TypeToken<DocumentCreateFromTemplateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createFromTemplateAsync(DocumentFromTemplateRequest documentFromTemplateRequest, final ApiCallback<DocumentCreateFromTemplateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createFromTemplateValidateBeforeCall(documentFromTemplateRequest, _callback);
        Type localVarReturnType = new TypeToken<DocumentCreateFromTemplateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateFromTemplateRequestBuilder {
        private final List<TemplateRecipientsMapInner> recipients;
        private Boolean testMode;
        private UUID templateId;
        private List<String> templateIds;
        private String name;
        private String subject;
        private String message;
        private Boolean draft;
        private Boolean withSignaturePage;
        private Integer expiresIn;
        private Boolean reminders;
        private Boolean applySigningOrder;
        private UUID apiApplicationId;
        private Boolean embeddedSigning;
        private Boolean embeddedSigningNotifications;
        private Boolean textTags;
        private String customRequesterName;
        private String customRequesterEmail;
        private String redirectUrl;
        private Boolean allowDecline;
        private Boolean allowReassign;
        private String declineRedirectUrl;
        private Object metadata;
        private List<TemplateFieldsMapInner> templateFields;
        private List<AdditionalFilesMapInner> files;
        private List<List<AdditionalFieldsMapInnerInner>> fields;
        private List<AttachmentRequestsMapInner> attachmentRequests;
        private List<CopiedContactsMapInner> copiedContacts;

        private CreateFromTemplateRequestBuilder(List<TemplateRecipientsMapInner> recipients) {
            this.recipients = recipients;
        }

        /**
         * Set testMode
         * @param testMode Set to &#x60;true&#x60; to enable Test Mode. Documents created with Test Mode do not count towards API billing and are not legally binding. Defaults to &#x60;false&#x60; (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder testMode(Boolean testMode) {
            this.testMode = testMode;
            return this;
        }
        
        /**
         * Set templateId
         * @param templateId Use when you have to create a document from a single template. Either :template_id or :template_ids must be present in the request, not both. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder templateId(UUID templateId) {
            this.templateId = templateId;
            return this;
        }
        
        /**
         * Set templateIds
         * @param templateIds Use when you have to create a document from multiple templates. Either :template_id or :template_ids must be present in the request, not both. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder templateIds(List<String> templateIds) {
            this.templateIds = templateIds;
            return this;
        }
        
        /**
         * Set name
         * @param name The name of the document. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Email subject for the signature request that recipients will see. Defaults to the default system subject or a template subject (if the document is created from a template). (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set message
         * @param message Email message for the signature request that recipients will see. Defaults to the default system message or a template message (if the document is created from a template). (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder message(String message) {
            this.message = message;
            return this;
        }
        
        /**
         * Set draft
         * @param draft Whether the document can still be updated before sending a signature request. If set to &#x60;false&#x60; the document is sent for signing as part of this request. Defaults to &#x60;false&#x60;. (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder draft(Boolean draft) {
            this.draft = draft;
            return this;
        }
        
        /**
         * Set withSignaturePage
         * @param withSignaturePage When set to &#x60;true&#x60; the document will have a signature page added to the end, and all signers will be required to add their signature on that page. (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder withSignaturePage(Boolean withSignaturePage) {
            this.withSignaturePage = withSignaturePage;
            return this;
        }
        
        /**
         * Set expiresIn
         * @param expiresIn Number of days before the signature request expires. Defaults to the account expiration setting or template expiration (if the document is created from a template). (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder expiresIn(Integer expiresIn) {
            this.expiresIn = expiresIn;
            return this;
        }
        
        /**
         * Set reminders
         * @param reminders Whether to send signing reminders to recipients. Reminders are sent on day 3, day 6, and day 10 if set to &#x60;true&#x60;. Defaults to &#x60;true&#x60;. (optional, default to true)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder reminders(Boolean reminders) {
            this.reminders = reminders;
            return this;
        }
        
        /**
         * Set applySigningOrder
         * @param applySigningOrder When set to &#x60;true&#x60; recipients will sign one at a time in the order of the &#x60;recipients&#x60; collection of this request. (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder applySigningOrder(Boolean applySigningOrder) {
            this.applySigningOrder = applySigningOrder;
            return this;
        }
        
        /**
         * Set apiApplicationId
         * @param apiApplicationId Unique identifier for API Application settings to use. API Applications are optional and mainly used when isolating OAuth apps or for more control over embedded API settings (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder apiApplicationId(UUID apiApplicationId) {
            this.apiApplicationId = apiApplicationId;
            return this;
        }
        
        /**
         * Set embeddedSigning
         * @param embeddedSigning When set to &#x60;true&#x60; it enables embedded signing in your website/web application. Embedded functionality works with an iFrame and email authentication is disabled. :embedded_signinig defaults to &#x60;false&#x60;. (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder embeddedSigning(Boolean embeddedSigning) {
            this.embeddedSigning = embeddedSigning;
            return this;
        }
        
        /**
         * Set embeddedSigningNotifications
         * @param embeddedSigningNotifications On embedding signing, document owners (and CC&#39;d contacts) do not get a notification email when documents have been completed. Setting this param to &#x60;true&#x60; will send out those final completed notifications. Default is &#x60;false&#x60; (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder embeddedSigningNotifications(Boolean embeddedSigningNotifications) {
            this.embeddedSigningNotifications = embeddedSigningNotifications;
            return this;
        }
        
        /**
         * Set textTags
         * @param textTags An alternative way (if you can’t use the recommended way) of placing fields in specific locations of your document by using special text tags. Useful when changing the content of your files changes the location of fields. See API documentation for “Text Tags” for details. Defaults to false. (optional, default to false)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder textTags(Boolean textTags) {
            this.textTags = textTags;
            return this;
        }
        
        /**
         * Set customRequesterName
         * @param customRequesterName Sets the custom requester name for the document. When set, this is the name used for all email communications, signing notifications, and in the audit file. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder customRequesterName(String customRequesterName) {
            this.customRequesterName = customRequesterName;
            return this;
        }
        
        /**
         * Set customRequesterEmail
         * @param customRequesterEmail Sets the custom requester email for the document. When set, this is the email used for all email communications, signing notifications, and in the audit file. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder customRequesterEmail(String customRequesterEmail) {
            this.customRequesterEmail = customRequesterEmail;
            return this;
        }
        
        /**
         * Set redirectUrl
         * @param redirectUrl A URL that recipients are redirected to after successfully signing a document. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder redirectUrl(String redirectUrl) {
            this.redirectUrl = redirectUrl;
            return this;
        }
        
        /**
         * Set allowDecline
         * @param allowDecline Whether to allow recipients the option to decline signing a document. If multiple signers are involved in a document, any single recipient can cancel the entire document signing process by declining to sign. (optional, default to true)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder allowDecline(Boolean allowDecline) {
            this.allowDecline = allowDecline;
            return this;
        }
        
        /**
         * Set allowReassign
         * @param allowReassign In some cases a signer is not the right person to sign and may need to reassign their signing responsibilities to another person. This feature allows them to reassign the document to someone else. (optional, default to true)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder allowReassign(Boolean allowReassign) {
            this.allowReassign = allowReassign;
            return this;
        }
        
        /**
         * Set declineRedirectUrl
         * @param declineRedirectUrl A URL that recipients are redirected to if the document is declined. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder declineRedirectUrl(String declineRedirectUrl) {
            this.declineRedirectUrl = declineRedirectUrl;
            return this;
        }
        
        /**
         * Set metadata
         * @param metadata Optional key-value data that can be associated with the document. If set, will be available every time the document data is returned. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder metadata(Object metadata) {
            this.metadata = metadata;
            return this;
        }
        
        /**
         * Set templateFields
         * @param templateFields Fields of your template(s) that you can prepopulate with values. Signature and Initials fields cannot be signed through the API. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder templateFields(List<TemplateFieldsMapInner> templateFields) {
            this.templateFields = templateFields;
            return this;
        }
        
        /**
         * Set files
         * @param files  (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder files(List<AdditionalFilesMapInner> files) {
            this.files = files;
            return this;
        }
        
        /**
         * Set fields
         * @param fields Fields to be added to any appended files (not existing files). Document fields placed on a document for collecting data or signatures from recipients. Field data should be sent as a 2-dimensional JSON array. One array of fields is needed for each file in the files array. An array of fields can be empty if you have a file that does not contain any fields. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder fields(List<List<AdditionalFieldsMapInnerInner>> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set attachmentRequests
         * @param attachmentRequests Attachments that a recipient must upload to complete the signing process. Attachment requests are shown after all document fields have been completed. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder attachmentRequests(List<AttachmentRequestsMapInner> attachmentRequests) {
            this.attachmentRequests = attachmentRequests;
            return this;
        }
        
        /**
         * Set copiedContacts
         * @param copiedContacts Copied contacts are emailed the final document once it has been completed by all recipients. (optional)
         * @return CreateFromTemplateRequestBuilder
         */
        public CreateFromTemplateRequestBuilder copiedContacts(List<CopiedContactsMapInner> copiedContacts) {
            this.copiedContacts = copiedContacts;
            return this;
        }
        
        /**
         * Build call for createFromTemplate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            DocumentFromTemplateRequest documentFromTemplateRequest = buildBodyParams();
            return createFromTemplateCall(documentFromTemplateRequest, _callback);
        }

        private DocumentFromTemplateRequest buildBodyParams() {
            DocumentFromTemplateRequest documentFromTemplateRequest = new DocumentFromTemplateRequest();
            documentFromTemplateRequest.testMode(this.testMode);
            documentFromTemplateRequest.templateId(this.templateId);
            documentFromTemplateRequest.templateIds(this.templateIds);
            documentFromTemplateRequest.name(this.name);
            documentFromTemplateRequest.subject(this.subject);
            documentFromTemplateRequest.message(this.message);
            documentFromTemplateRequest.recipients(this.recipients);
            documentFromTemplateRequest.draft(this.draft);
            documentFromTemplateRequest.withSignaturePage(this.withSignaturePage);
            documentFromTemplateRequest.expiresIn(this.expiresIn);
            documentFromTemplateRequest.reminders(this.reminders);
            documentFromTemplateRequest.applySigningOrder(this.applySigningOrder);
            documentFromTemplateRequest.apiApplicationId(this.apiApplicationId);
            documentFromTemplateRequest.embeddedSigning(this.embeddedSigning);
            documentFromTemplateRequest.embeddedSigningNotifications(this.embeddedSigningNotifications);
            documentFromTemplateRequest.textTags(this.textTags);
            documentFromTemplateRequest.customRequesterName(this.customRequesterName);
            documentFromTemplateRequest.customRequesterEmail(this.customRequesterEmail);
            documentFromTemplateRequest.redirectUrl(this.redirectUrl);
            documentFromTemplateRequest.allowDecline(this.allowDecline);
            documentFromTemplateRequest.allowReassign(this.allowReassign);
            documentFromTemplateRequest.declineRedirectUrl(this.declineRedirectUrl);
            documentFromTemplateRequest.metadata(this.metadata);
            documentFromTemplateRequest.templateFields(this.templateFields);
            documentFromTemplateRequest.files(this.files);
            documentFromTemplateRequest.fields(this.fields);
            documentFromTemplateRequest.attachmentRequests(this.attachmentRequests);
            documentFromTemplateRequest.copiedContacts(this.copiedContacts);
            return documentFromTemplateRequest;
        }

        /**
         * Execute createFromTemplate request
         * @return DocumentCreateFromTemplateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public DocumentCreateFromTemplateResponse execute() throws ApiException {
            DocumentFromTemplateRequest documentFromTemplateRequest = buildBodyParams();
            ApiResponse<DocumentCreateFromTemplateResponse> localVarResp = createFromTemplateWithHttpInfo(documentFromTemplateRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createFromTemplate request with HTTP info returned
         * @return ApiResponse&lt;DocumentCreateFromTemplateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DocumentCreateFromTemplateResponse> executeWithHttpInfo() throws ApiException {
            DocumentFromTemplateRequest documentFromTemplateRequest = buildBodyParams();
            return createFromTemplateWithHttpInfo(documentFromTemplateRequest);
        }

        /**
         * Execute createFromTemplate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DocumentCreateFromTemplateResponse> _callback) throws ApiException {
            DocumentFromTemplateRequest documentFromTemplateRequest = buildBodyParams();
            return createFromTemplateAsync(documentFromTemplateRequest, _callback);
        }
    }

    /**
     * Create Document from Template
     * Creates and optionally sends a new document for signing. If &#x60;draft&#x60; is set to false the document will not be sent.
     * @return CreateFromTemplateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
     </table>
     */
    public CreateFromTemplateRequestBuilder createFromTemplate(List<TemplateRecipientsMapInner> recipients) throws IllegalArgumentException {
        if (recipients == null) throw new IllegalArgumentException("\"recipients\" is required but got null");
        return new CreateFromTemplateRequestBuilder(recipients);
    }
    private okhttp3.Call createNewDocumentCall(DocumentRequest documentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = documentRequest;

        // create path and map variables
        String localVarPath = "/api/v1/documents";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createNewDocumentValidateBeforeCall(DocumentRequest documentRequest, final ApiCallback _callback) throws ApiException {
        return createNewDocumentCall(documentRequest, _callback);

    }


    private ApiResponse<DocumentCreateNewDocumentResponse> createNewDocumentWithHttpInfo(DocumentRequest documentRequest) throws ApiException {
        okhttp3.Call localVarCall = createNewDocumentValidateBeforeCall(documentRequest, null);
        Type localVarReturnType = new TypeToken<DocumentCreateNewDocumentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createNewDocumentAsync(DocumentRequest documentRequest, final ApiCallback<DocumentCreateNewDocumentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createNewDocumentValidateBeforeCall(documentRequest, _callback);
        Type localVarReturnType = new TypeToken<DocumentCreateNewDocumentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateNewDocumentRequestBuilder {
        private final List<FilesMapInner> files;
        private final List<DocumentRecipientsMapInner> recipients;
        private Boolean testMode;
        private String name;
        private String subject;
        private String message;
        private Boolean draft;
        private Boolean withSignaturePage;
        private Integer expiresIn;
        private Boolean reminders;
        private Boolean applySigningOrder;
        private UUID apiApplicationId;
        private Boolean embeddedSigning;
        private Boolean embeddedSigningNotifications;
        private Boolean textTags;
        private String customRequesterName;
        private String customRequesterEmail;
        private String redirectUrl;
        private Boolean allowDecline;
        private Boolean allowReassign;
        private String declineRedirectUrl;
        private Object metadata;
        private List<List<FieldsMapInnerInner>> fields;
        private List<AttachmentRequestsMapInner> attachmentRequests;
        private List<CopiedContactsMapInner> copiedContacts;

        private CreateNewDocumentRequestBuilder(List<FilesMapInner> files, List<DocumentRecipientsMapInner> recipients) {
            this.files = files;
            this.recipients = recipients;
        }

        /**
         * Set testMode
         * @param testMode Set to &#x60;true&#x60; to enable Test Mode. Documents created with Test Mode do not count towards API billing and are not legally binding. Defaults to &#x60;false&#x60; (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder testMode(Boolean testMode) {
            this.testMode = testMode;
            return this;
        }
        
        /**
         * Set name
         * @param name The name of the document. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Email subject for the signature request that recipients will see. Defaults to the default system subject or a template subject (if the document is created from a template). (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set message
         * @param message Email message for the signature request that recipients will see. Defaults to the default system message or a template message (if the document is created from a template). (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder message(String message) {
            this.message = message;
            return this;
        }
        
        /**
         * Set draft
         * @param draft Whether the document can still be updated before sending a signature request. If set to &#x60;false&#x60; the document is sent for signing as part of this request. Defaults to &#x60;false&#x60;. (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder draft(Boolean draft) {
            this.draft = draft;
            return this;
        }
        
        /**
         * Set withSignaturePage
         * @param withSignaturePage When set to &#x60;true&#x60; the document will have a signature page added to the end, and all signers will be required to add their signature on that page. (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder withSignaturePage(Boolean withSignaturePage) {
            this.withSignaturePage = withSignaturePage;
            return this;
        }
        
        /**
         * Set expiresIn
         * @param expiresIn Number of days before the signature request expires. Defaults to the account expiration setting or template expiration (if the document is created from a template). (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder expiresIn(Integer expiresIn) {
            this.expiresIn = expiresIn;
            return this;
        }
        
        /**
         * Set reminders
         * @param reminders Whether to send signing reminders to recipients. Reminders are sent on day 3, day 6, and day 10 if set to &#x60;true&#x60;. Defaults to &#x60;true&#x60;. (optional, default to true)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder reminders(Boolean reminders) {
            this.reminders = reminders;
            return this;
        }
        
        /**
         * Set applySigningOrder
         * @param applySigningOrder When set to &#x60;true&#x60; recipients will sign one at a time in the order of the &#x60;recipients&#x60; collection of this request. (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder applySigningOrder(Boolean applySigningOrder) {
            this.applySigningOrder = applySigningOrder;
            return this;
        }
        
        /**
         * Set apiApplicationId
         * @param apiApplicationId Unique identifier for API Application settings to use. API Applications are optional and mainly used when isolating OAuth apps or for more control over embedded API settings (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder apiApplicationId(UUID apiApplicationId) {
            this.apiApplicationId = apiApplicationId;
            return this;
        }
        
        /**
         * Set embeddedSigning
         * @param embeddedSigning When set to &#x60;true&#x60; it enables embedded signing in your website/web application. Embedded functionality works with an iFrame and email authentication is disabled. :embedded_signinig defaults to &#x60;false&#x60;. (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder embeddedSigning(Boolean embeddedSigning) {
            this.embeddedSigning = embeddedSigning;
            return this;
        }
        
        /**
         * Set embeddedSigningNotifications
         * @param embeddedSigningNotifications On embedding signing, document owners (and CC&#39;d contacts) do not get a notification email when documents have been completed. Setting this param to &#x60;true&#x60; will send out those final completed notifications. Default is &#x60;false&#x60; (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder embeddedSigningNotifications(Boolean embeddedSigningNotifications) {
            this.embeddedSigningNotifications = embeddedSigningNotifications;
            return this;
        }
        
        /**
         * Set textTags
         * @param textTags An alternative way (if you can’t use the recommended way) of placing fields in specific locations of your document by using special text tags. Useful when changing the content of your files changes the location of fields. See API documentation for “Text Tags” for details. Defaults to false. (optional, default to false)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder textTags(Boolean textTags) {
            this.textTags = textTags;
            return this;
        }
        
        /**
         * Set customRequesterName
         * @param customRequesterName Sets the custom requester name for the document. When set, this is the name used for all email communications, signing notifications, and in the audit file. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder customRequesterName(String customRequesterName) {
            this.customRequesterName = customRequesterName;
            return this;
        }
        
        /**
         * Set customRequesterEmail
         * @param customRequesterEmail Sets the custom requester email for the document. When set, this is the email used for all email communications, signing notifications, and in the audit file. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder customRequesterEmail(String customRequesterEmail) {
            this.customRequesterEmail = customRequesterEmail;
            return this;
        }
        
        /**
         * Set redirectUrl
         * @param redirectUrl A URL that recipients are redirected to after successfully signing a document. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder redirectUrl(String redirectUrl) {
            this.redirectUrl = redirectUrl;
            return this;
        }
        
        /**
         * Set allowDecline
         * @param allowDecline Whether to allow recipients the option to decline signing a document. If multiple signers are involved in a document, any single recipient can cancel the entire document signing process by declining to sign. (optional, default to true)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder allowDecline(Boolean allowDecline) {
            this.allowDecline = allowDecline;
            return this;
        }
        
        /**
         * Set allowReassign
         * @param allowReassign In some cases a signer is not the right person to sign and may need to reassign their signing responsibilities to another person. This feature allows them to reassign the document to someone else. (optional, default to true)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder allowReassign(Boolean allowReassign) {
            this.allowReassign = allowReassign;
            return this;
        }
        
        /**
         * Set declineRedirectUrl
         * @param declineRedirectUrl A URL that recipients are redirected to if the document is declined. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder declineRedirectUrl(String declineRedirectUrl) {
            this.declineRedirectUrl = declineRedirectUrl;
            return this;
        }
        
        /**
         * Set metadata
         * @param metadata Optional key-value data that can be associated with the document. If set, will be available every time the document data is returned. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder metadata(Object metadata) {
            this.metadata = metadata;
            return this;
        }
        
        /**
         * Set fields
         * @param fields Document fields placed on a document for collecting data or signatures from recipients. At least one field must be present in the Create Document request if &#x60;draft&#x60; is &#x60;false&#x60; (unless adding a signature page by using &#x60;with_signature_page&#x60;). Field data should be sent as a 2-dimensional JSON array. One array of fields is needed for each file in the files array. An array of fields can be empty if you have a file that does not contain any fields. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder fields(List<List<FieldsMapInnerInner>> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set attachmentRequests
         * @param attachmentRequests Attachments that a recipient must upload to complete the signing process. Attachment requests are shown after all document fields have been completed. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder attachmentRequests(List<AttachmentRequestsMapInner> attachmentRequests) {
            this.attachmentRequests = attachmentRequests;
            return this;
        }
        
        /**
         * Set copiedContacts
         * @param copiedContacts Copied contacts are emailed the final document once it has been completed by all recipients. (optional)
         * @return CreateNewDocumentRequestBuilder
         */
        public CreateNewDocumentRequestBuilder copiedContacts(List<CopiedContactsMapInner> copiedContacts) {
            this.copiedContacts = copiedContacts;
            return this;
        }
        
        /**
         * Build call for createNewDocument
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            DocumentRequest documentRequest = buildBodyParams();
            return createNewDocumentCall(documentRequest, _callback);
        }

        private DocumentRequest buildBodyParams() {
            DocumentRequest documentRequest = new DocumentRequest();
            documentRequest.testMode(this.testMode);
            documentRequest.files(this.files);
            documentRequest.name(this.name);
            documentRequest.subject(this.subject);
            documentRequest.message(this.message);
            documentRequest.recipients(this.recipients);
            documentRequest.draft(this.draft);
            documentRequest.withSignaturePage(this.withSignaturePage);
            documentRequest.expiresIn(this.expiresIn);
            documentRequest.reminders(this.reminders);
            documentRequest.applySigningOrder(this.applySigningOrder);
            documentRequest.apiApplicationId(this.apiApplicationId);
            documentRequest.embeddedSigning(this.embeddedSigning);
            documentRequest.embeddedSigningNotifications(this.embeddedSigningNotifications);
            documentRequest.textTags(this.textTags);
            documentRequest.customRequesterName(this.customRequesterName);
            documentRequest.customRequesterEmail(this.customRequesterEmail);
            documentRequest.redirectUrl(this.redirectUrl);
            documentRequest.allowDecline(this.allowDecline);
            documentRequest.allowReassign(this.allowReassign);
            documentRequest.declineRedirectUrl(this.declineRedirectUrl);
            documentRequest.metadata(this.metadata);
            documentRequest.fields(this.fields);
            documentRequest.attachmentRequests(this.attachmentRequests);
            documentRequest.copiedContacts(this.copiedContacts);
            return documentRequest;
        }

        /**
         * Execute createNewDocument request
         * @return DocumentCreateNewDocumentResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public DocumentCreateNewDocumentResponse execute() throws ApiException {
            DocumentRequest documentRequest = buildBodyParams();
            ApiResponse<DocumentCreateNewDocumentResponse> localVarResp = createNewDocumentWithHttpInfo(documentRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createNewDocument request with HTTP info returned
         * @return ApiResponse&lt;DocumentCreateNewDocumentResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DocumentCreateNewDocumentResponse> executeWithHttpInfo() throws ApiException {
            DocumentRequest documentRequest = buildBodyParams();
            return createNewDocumentWithHttpInfo(documentRequest);
        }

        /**
         * Execute createNewDocument request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DocumentCreateNewDocumentResponse> _callback) throws ApiException {
            DocumentRequest documentRequest = buildBodyParams();
            return createNewDocumentAsync(documentRequest, _callback);
        }
    }

    /**
     * Create Document
     * Creates and optionally sends a new document for signing. If &#x60;draft&#x60; is set to false the document will not be sent.
     * @return CreateNewDocumentRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
     </table>
     */
    public CreateNewDocumentRequestBuilder createNewDocument(List<FilesMapInner> files, List<DocumentRecipientsMapInner> recipients) throws IllegalArgumentException {
        if (files == null) throw new IllegalArgumentException("\"files\" is required but got null");
        if (recipients == null) throw new IllegalArgumentException("\"recipients\" is required but got null");
        return new CreateNewDocumentRequestBuilder(files, recipients);
    }
    private okhttp3.Call deleteDocumentCall(UUID id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/documents/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteDocumentValidateBeforeCall(UUID id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteDocument(Async)");
        }

        return deleteDocumentCall(id, _callback);

    }


    private ApiResponse<Void> deleteDocumentWithHttpInfo(UUID id) throws ApiException {
        okhttp3.Call localVarCall = deleteDocumentValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteDocumentAsync(UUID id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteDocumentValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteDocumentRequestBuilder {
        private final UUID id;

        private DeleteDocumentRequestBuilder(UUID id) {
            this.id = id;
        }

        /**
         * Build call for deleteDocument
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteDocumentCall(id, _callback);
        }


        /**
         * Execute deleteDocument request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteDocumentWithHttpInfo(id);
        }

        /**
         * Execute deleteDocument request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteDocumentWithHttpInfo(id);
        }

        /**
         * Execute deleteDocument request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteDocumentAsync(id, _callback);
        }
    }

    /**
     * Delete Document
     * Deletes a document. Deleting a document will also cancel document signing (if in progress).  Supply the unique document ID from either a Create Document request or document page URL.
     * @param id  (required)
     * @return DeleteDocumentRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
     </table>
     */
    public DeleteDocumentRequestBuilder deleteDocument(UUID id) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new DeleteDocumentRequestBuilder(id);
    }
    private okhttp3.Call getCompletedPdfCall(UUID id, Boolean urlOnly, Boolean auditPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/documents/{id}/completed_pdf"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (urlOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url_only", urlOnly));
        }

        if (auditPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audit_page", auditPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCompletedPdfValidateBeforeCall(UUID id, Boolean urlOnly, Boolean auditPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getCompletedPdf(Async)");
        }

        return getCompletedPdfCall(id, urlOnly, auditPage, _callback);

    }


    private ApiResponse<Object> getCompletedPdfWithHttpInfo(UUID id, Boolean urlOnly, Boolean auditPage) throws ApiException {
        okhttp3.Call localVarCall = getCompletedPdfValidateBeforeCall(id, urlOnly, auditPage, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCompletedPdfAsync(UUID id, Boolean urlOnly, Boolean auditPage, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCompletedPdfValidateBeforeCall(id, urlOnly, auditPage, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCompletedPdfRequestBuilder {
        private final UUID id;
        private Boolean urlOnly;
        private Boolean auditPage;

        private GetCompletedPdfRequestBuilder(UUID id) {
            this.id = id;
        }

        /**
         * Set urlOnly
         * @param urlOnly  (optional, default to false)
         * @return GetCompletedPdfRequestBuilder
         */
        public GetCompletedPdfRequestBuilder urlOnly(Boolean urlOnly) {
            this.urlOnly = urlOnly;
            return this;
        }
        
        /**
         * Set auditPage
         * @param auditPage  (optional, default to true)
         * @return GetCompletedPdfRequestBuilder
         */
        public GetCompletedPdfRequestBuilder auditPage(Boolean auditPage) {
            this.auditPage = auditPage;
            return this;
        }
        
        /**
         * Build call for getCompletedPdf
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful, returns the final completed PDF, or if url_only is set to true, a JSON object is returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCompletedPdfCall(id, urlOnly, auditPage, _callback);
        }


        /**
         * Execute getCompletedPdf request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful, returns the final completed PDF, or if url_only is set to true, a JSON object is returned. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getCompletedPdfWithHttpInfo(id, urlOnly, auditPage);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCompletedPdf request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful, returns the final completed PDF, or if url_only is set to true, a JSON object is returned. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getCompletedPdfWithHttpInfo(id, urlOnly, auditPage);
        }

        /**
         * Execute getCompletedPdf request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful, returns the final completed PDF, or if url_only is set to true, a JSON object is returned. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getCompletedPdfAsync(id, urlOnly, auditPage, _callback);
        }
    }

    /**
     * Completed PDF
     * Gets a completed document PDF. Supply the unique document ID from either a document creation request or document page URL.
     * @param id  (required)
     * @return GetCompletedPdfRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful, returns the final completed PDF, or if url_only is set to true, a JSON object is returned. </td><td>  -  </td></tr>
     </table>
     */
    public GetCompletedPdfRequestBuilder getCompletedPdf(UUID id) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new GetCompletedPdfRequestBuilder(id);
    }
    private okhttp3.Call getDocumentDataCall(UUID id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/documents/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDocumentDataValidateBeforeCall(UUID id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getDocumentData(Async)");
        }

        return getDocumentDataCall(id, _callback);

    }


    private ApiResponse<DocumentGetDocumentDataResponse> getDocumentDataWithHttpInfo(UUID id) throws ApiException {
        okhttp3.Call localVarCall = getDocumentDataValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<DocumentGetDocumentDataResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getDocumentDataAsync(UUID id, final ApiCallback<DocumentGetDocumentDataResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDocumentDataValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<DocumentGetDocumentDataResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetDocumentDataRequestBuilder {
        private final UUID id;

        private GetDocumentDataRequestBuilder(UUID id) {
            this.id = id;
        }

        /**
         * Build call for getDocumentData
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getDocumentDataCall(id, _callback);
        }


        /**
         * Execute getDocumentData request
         * @return DocumentGetDocumentDataResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful </td><td>  -  </td></tr>
         </table>
         */
        public DocumentGetDocumentDataResponse execute() throws ApiException {
            ApiResponse<DocumentGetDocumentDataResponse> localVarResp = getDocumentDataWithHttpInfo(id);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getDocumentData request with HTTP info returned
         * @return ApiResponse&lt;DocumentGetDocumentDataResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DocumentGetDocumentDataResponse> executeWithHttpInfo() throws ApiException {
            return getDocumentDataWithHttpInfo(id);
        }

        /**
         * Execute getDocumentData request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> successful </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DocumentGetDocumentDataResponse> _callback) throws ApiException {
            return getDocumentDataAsync(id, _callback);
        }
    }

    /**
     * Get Document
     * Returns a document and all associated document data. Supply the unique document ID from either a document creation request or Document page URL.
     * @param id  (required)
     * @return GetDocumentDataRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful </td><td>  -  </td></tr>
     </table>
     */
    public GetDocumentDataRequestBuilder getDocumentData(UUID id) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new GetDocumentDataRequestBuilder(id);
    }
    private okhttp3.Call sendReminderCall(UUID id, SendReminderRequest sendReminderRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = sendReminderRequest;

        // create path and map variables
        String localVarPath = "/api/v1/documents/{id}/remind"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sendReminderValidateBeforeCall(UUID id, SendReminderRequest sendReminderRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling sendReminder(Async)");
        }

        return sendReminderCall(id, sendReminderRequest, _callback);

    }


    private ApiResponse<DocumentSendReminderResponse> sendReminderWithHttpInfo(UUID id, SendReminderRequest sendReminderRequest) throws ApiException {
        okhttp3.Call localVarCall = sendReminderValidateBeforeCall(id, sendReminderRequest, null);
        Type localVarReturnType = new TypeToken<DocumentSendReminderResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call sendReminderAsync(UUID id, SendReminderRequest sendReminderRequest, final ApiCallback<DocumentSendReminderResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = sendReminderValidateBeforeCall(id, sendReminderRequest, _callback);
        Type localVarReturnType = new TypeToken<DocumentSendReminderResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SendReminderRequestBuilder {
        private final UUID id;
        private List<RemindRecipientsMapInner> recipients;

        private SendReminderRequestBuilder(UUID id) {
            this.id = id;
        }

        /**
         * Set recipients
         * @param recipients Optional list if recipients within the document to send a reminder email to. If none are specified, all recipients that have not signed yet will receive a reminder email. (optional)
         * @return SendReminderRequestBuilder
         */
        public SendReminderRequestBuilder recipients(List<RemindRecipientsMapInner> recipients) {
            this.recipients = recipients;
            return this;
        }
        
        /**
         * Build call for sendReminder
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SendReminderRequest sendReminderRequest = buildBodyParams();
            return sendReminderCall(id, sendReminderRequest, _callback);
        }

        private SendReminderRequest buildBodyParams() {
            SendReminderRequest sendReminderRequest = new SendReminderRequest();
            sendReminderRequest.recipients(this.recipients);
            return sendReminderRequest;
        }

        /**
         * Execute sendReminder request
         * @return DocumentSendReminderResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public DocumentSendReminderResponse execute() throws ApiException {
            SendReminderRequest sendReminderRequest = buildBodyParams();
            ApiResponse<DocumentSendReminderResponse> localVarResp = sendReminderWithHttpInfo(id, sendReminderRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute sendReminder request with HTTP info returned
         * @return ApiResponse&lt;DocumentSendReminderResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DocumentSendReminderResponse> executeWithHttpInfo() throws ApiException {
            SendReminderRequest sendReminderRequest = buildBodyParams();
            return sendReminderWithHttpInfo(id, sendReminderRequest);
        }

        /**
         * Execute sendReminder request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DocumentSendReminderResponse> _callback) throws ApiException {
            SendReminderRequest sendReminderRequest = buildBodyParams();
            return sendReminderAsync(id, sendReminderRequest, _callback);
        }
    }

    /**
     * Send Reminder
     * Sends a reminder email to recipients that have not signed yet.
     * @param id  (required)
     * @return SendReminderRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
     </table>
     */
    public SendReminderRequestBuilder sendReminder(UUID id) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new SendReminderRequestBuilder(id);
    }
    private okhttp3.Call updateAndSendCall(UUID id, UpdateDocumentAndSendRequest updateDocumentAndSendRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateDocumentAndSendRequest;

        // create path and map variables
        String localVarPath = "/api/v1/documents/{id}/send"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateAndSendValidateBeforeCall(UUID id, UpdateDocumentAndSendRequest updateDocumentAndSendRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateAndSend(Async)");
        }

        return updateAndSendCall(id, updateDocumentAndSendRequest, _callback);

    }


    private ApiResponse<DocumentUpdateAndSendResponse> updateAndSendWithHttpInfo(UUID id, UpdateDocumentAndSendRequest updateDocumentAndSendRequest) throws ApiException {
        okhttp3.Call localVarCall = updateAndSendValidateBeforeCall(id, updateDocumentAndSendRequest, null);
        Type localVarReturnType = new TypeToken<DocumentUpdateAndSendResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateAndSendAsync(UUID id, UpdateDocumentAndSendRequest updateDocumentAndSendRequest, final ApiCallback<DocumentUpdateAndSendResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateAndSendValidateBeforeCall(id, updateDocumentAndSendRequest, _callback);
        Type localVarReturnType = new TypeToken<DocumentUpdateAndSendResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateAndSendRequestBuilder {
        private final UUID id;
        private Boolean testMode;
        private String name;
        private String subject;
        private String message;
        private Integer expiresIn;
        private Boolean reminders;
        private Boolean applySigningOrder;
        private UUID apiApplicationId;
        private Boolean embeddedSigning;
        private Boolean embeddedSigningNotifications;
        private String customRequesterName;
        private String customRequesterEmail;
        private String redirectUrl;
        private Boolean allowDecline;
        private Boolean allowReassign;
        private String declineRedirectUrl;
        private Object metadata;

        private UpdateAndSendRequestBuilder(UUID id) {
            this.id = id;
        }

        /**
         * Set testMode
         * @param testMode Set to &#x60;true&#x60; to enable Test Mode. Documents created with Test Mode do not count towards API billing and are not legally binding. Defaults to &#x60;false&#x60; (optional, default to false)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder testMode(Boolean testMode) {
            this.testMode = testMode;
            return this;
        }
        
        /**
         * Set name
         * @param name The name of the document. (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Email subject for the signature request that recipients will see. Defaults to the default system subject or a template subject (if the document is created from a template). (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set message
         * @param message Email message for the signature request that recipients will see. Defaults to the default system message or a template message (if the document is created from a template). (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder message(String message) {
            this.message = message;
            return this;
        }
        
        /**
         * Set expiresIn
         * @param expiresIn Number of days before the signature request expires. Defaults to the account expiration setting or template expiration (if the document is created from a template). (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder expiresIn(Integer expiresIn) {
            this.expiresIn = expiresIn;
            return this;
        }
        
        /**
         * Set reminders
         * @param reminders Whether to send signing reminders to recipients. Reminders are sent on day 3, day 6, and day 10 if set to &#x60;true&#x60;. Defaults to &#x60;true&#x60;. (optional, default to true)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder reminders(Boolean reminders) {
            this.reminders = reminders;
            return this;
        }
        
        /**
         * Set applySigningOrder
         * @param applySigningOrder When set to &#x60;true&#x60; recipients will sign one at a time in the order of the &#x60;recipients&#x60; collection of this request. (optional, default to false)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder applySigningOrder(Boolean applySigningOrder) {
            this.applySigningOrder = applySigningOrder;
            return this;
        }
        
        /**
         * Set apiApplicationId
         * @param apiApplicationId Unique identifier for API Application settings to use. API Applications are optional and mainly used when isolating OAuth apps or for more control over embedded API settings (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder apiApplicationId(UUID apiApplicationId) {
            this.apiApplicationId = apiApplicationId;
            return this;
        }
        
        /**
         * Set embeddedSigning
         * @param embeddedSigning When set to &#x60;true&#x60; it enables embedded signing in your website/web application. Embedded functionality works with an iFrame and email authentication is disabled. :embedded_signinig defaults to &#x60;false&#x60;. (optional, default to false)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder embeddedSigning(Boolean embeddedSigning) {
            this.embeddedSigning = embeddedSigning;
            return this;
        }
        
        /**
         * Set embeddedSigningNotifications
         * @param embeddedSigningNotifications On embedding signing, document owners (and CC&#39;d contacts) do not get a notification email when documents have been completed. Setting this param to &#x60;true&#x60; will send out those final completed notifications. Default is &#x60;false&#x60; (optional, default to false)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder embeddedSigningNotifications(Boolean embeddedSigningNotifications) {
            this.embeddedSigningNotifications = embeddedSigningNotifications;
            return this;
        }
        
        /**
         * Set customRequesterName
         * @param customRequesterName Sets the custom requester name for the document. When set, this is the name used for all email communications, signing notifications, and in the audit file. (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder customRequesterName(String customRequesterName) {
            this.customRequesterName = customRequesterName;
            return this;
        }
        
        /**
         * Set customRequesterEmail
         * @param customRequesterEmail Sets the custom requester email for the document. When set, this is the email used for all email communications, signing notifications, and in the audit file. (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder customRequesterEmail(String customRequesterEmail) {
            this.customRequesterEmail = customRequesterEmail;
            return this;
        }
        
        /**
         * Set redirectUrl
         * @param redirectUrl A URL that recipients are redirected to after successfully signing a document. (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder redirectUrl(String redirectUrl) {
            this.redirectUrl = redirectUrl;
            return this;
        }
        
        /**
         * Set allowDecline
         * @param allowDecline Whether to allow recipients the option to decline signing a document. If multiple signers are involved in a document, any single recipient can cancel the entire document signing process by declining to sign. (optional, default to true)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder allowDecline(Boolean allowDecline) {
            this.allowDecline = allowDecline;
            return this;
        }
        
        /**
         * Set allowReassign
         * @param allowReassign In some cases a signer is not the right person to sign and may need to reassign their signing responsibilities to another person. This feature allows them to reassign the document to someone else. (optional, default to true)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder allowReassign(Boolean allowReassign) {
            this.allowReassign = allowReassign;
            return this;
        }
        
        /**
         * Set declineRedirectUrl
         * @param declineRedirectUrl A URL that recipients are redirected to if the document is declined. (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder declineRedirectUrl(String declineRedirectUrl) {
            this.declineRedirectUrl = declineRedirectUrl;
            return this;
        }
        
        /**
         * Set metadata
         * @param metadata Optional key-value data that can be associated with the document. If set, will be available every time the document data is returned. (optional)
         * @return UpdateAndSendRequestBuilder
         */
        public UpdateAndSendRequestBuilder metadata(Object metadata) {
            this.metadata = metadata;
            return this;
        }
        
        /**
         * Build call for updateAndSend
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UpdateDocumentAndSendRequest updateDocumentAndSendRequest = buildBodyParams();
            return updateAndSendCall(id, updateDocumentAndSendRequest, _callback);
        }

        private UpdateDocumentAndSendRequest buildBodyParams() {
            UpdateDocumentAndSendRequest updateDocumentAndSendRequest = new UpdateDocumentAndSendRequest();
            updateDocumentAndSendRequest.testMode(this.testMode);
            updateDocumentAndSendRequest.name(this.name);
            updateDocumentAndSendRequest.subject(this.subject);
            updateDocumentAndSendRequest.message(this.message);
            updateDocumentAndSendRequest.expiresIn(this.expiresIn);
            updateDocumentAndSendRequest.reminders(this.reminders);
            updateDocumentAndSendRequest.applySigningOrder(this.applySigningOrder);
            updateDocumentAndSendRequest.apiApplicationId(this.apiApplicationId);
            updateDocumentAndSendRequest.embeddedSigning(this.embeddedSigning);
            updateDocumentAndSendRequest.embeddedSigningNotifications(this.embeddedSigningNotifications);
            updateDocumentAndSendRequest.customRequesterName(this.customRequesterName);
            updateDocumentAndSendRequest.customRequesterEmail(this.customRequesterEmail);
            updateDocumentAndSendRequest.redirectUrl(this.redirectUrl);
            updateDocumentAndSendRequest.allowDecline(this.allowDecline);
            updateDocumentAndSendRequest.allowReassign(this.allowReassign);
            updateDocumentAndSendRequest.declineRedirectUrl(this.declineRedirectUrl);
            updateDocumentAndSendRequest.metadata(this.metadata);
            return updateDocumentAndSendRequest;
        }

        /**
         * Execute updateAndSend request
         * @return DocumentUpdateAndSendResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public DocumentUpdateAndSendResponse execute() throws ApiException {
            UpdateDocumentAndSendRequest updateDocumentAndSendRequest = buildBodyParams();
            ApiResponse<DocumentUpdateAndSendResponse> localVarResp = updateAndSendWithHttpInfo(id, updateDocumentAndSendRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateAndSend request with HTTP info returned
         * @return ApiResponse&lt;DocumentUpdateAndSendResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<DocumentUpdateAndSendResponse> executeWithHttpInfo() throws ApiException {
            UpdateDocumentAndSendRequest updateDocumentAndSendRequest = buildBodyParams();
            return updateAndSendWithHttpInfo(id, updateDocumentAndSendRequest);
        }

        /**
         * Execute updateAndSend request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<DocumentUpdateAndSendResponse> _callback) throws ApiException {
            UpdateDocumentAndSendRequest updateDocumentAndSendRequest = buildBodyParams();
            return updateAndSendAsync(id, updateDocumentAndSendRequest, _callback);
        }
    }

    /**
     * Update and Send Document
     * Updates a draft document and sends it to be signed by recipients.
     * @param id  (required)
     * @return UpdateAndSendRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> created </td><td>  -  </td></tr>
     </table>
     */
    public UpdateAndSendRequestBuilder updateAndSend(UUID id) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new UpdateAndSendRequestBuilder(id);
    }
}
